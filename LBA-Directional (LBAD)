string textbuffer;
string ctextbuffer;
integer delay;
integer damage;
integer link=LINK_THIS;//WHERE YOUR HP TEXT WILL BE DISPLAYED! DON'T FUCK UP!
integer hp;//This is your HP. It is affected by rez params, but on startup it turns 
integer maxhp=250;//Max HP of your hitbox, yo.
integer atcap=100;//Clamps damage over this amount to this damage. Don't be a faggot with it m8.
integer trigger=50;//At what damage anti-spam will trigger. Don't be an asshole with this or you will get blacklisted.
//These two are seperate integers so that vehicles may have high alpha strike damage without triggering the anti-spam. Trigger is only checked on multiple hits, ie, if X munition hits you X times and the culmative damage is over TRIGGER damage.
float frontmult=0.5;
float rearmult=1.75;
float sidemult=1;
float topmult=.75;
float bottommult=2;
///DONT BE STUPID WITH YOUR FUCKIN MULTIPLIERS OR ILL BANG YOUR DAD.
key user;
key rezzer;
die()
{
    //PUT ALL EXPLODEY SHIT AND SITBASE KILLING HOOKS IN HERE!!!!!
    //llResetScript(); // For Testing shit yo.
    //llSetObjectDesc("LBA.v.2.0,DEAD,<0,0,0>");//mbtlba plugin
    //llSleep(5);//Remove this if youre not using it for mbtlba
    llDie();
}
//DON'T TOUCH ANY OF THE SHIT BELOW THIS - REMEMBER, SAVE THIS IN MONO.
float rev=2.2;//Current revision number, for just making sure people know you're on version X Y Z.
list proc=[];//Damage events being processed into the buffer
list recent=[];//List of things that have already hurt you. Ignores multiple messages if they are not sourced from an attachment and over one damage.
float cleanup;//When the last cleaning of the recent list happened, so you don't get a stack heap lol.
list totals=[];//The combined damage from munitions, don't touch me either you fuckboy. Processed damage gets pushed into this
list buffer=[];//This builds the message for the ownersay when you get damaged, don't touch me either
list impactlist=[];///COLLISSION STORING FOR LBA-D
list blacklist=[];//List of keys that are a bunch of cock monglers, don't touch me, for one, and also this will be overwritten on blacklist communication.
integer lh;//Don't touch me
integer lh2;//For cleaning up listens on the reghex channel from regions you've left, Don't touch me please.
integer events=0;//How many events are happening in your processing event. 
vector min;
vector max;
//Bounding box values for checking against raycast rifles.
handlehp()//Updates your HP text. The only thing you should really dick with is the text display.
{
    integer t=10;
    string display="[";
    while(t)
    {
        if(hp>((10-t)*maxhp/10))display+="â–ˆ";
        else display+="-";
        --t;
    }
    display+="]";
    string info="LBA.v.D."+llGetSubString((string)rev,0,3)+","+(string)hp+","+(string)maxhp+","+(string)atcap+","+(string)trigger+",F-"+llGetSubString((string)frontmult,0,2)+",S-"+llGetSubString((string)sidemult,0,2)+",R-"+llGetSubString((string)rearmult,0,2)+",T-"+llGetSubString((string)topmult,0,2)+",B-"+llGetSubString((string)bottommult,0,2);
    
    ///Use this section for floattext reporting only
    llSetLinkPrimitiveParamsFast(link,[PRIM_TEXT,"\n"+textbuffer+"\n [LBA DIRECTIONAL] \n ["+(string)((integer)hp)+"/"+(string)((integer)maxhp)+"] \n "+display,<1.-(float)hp/maxhp,(float)hp/maxhp,0.>,1,PRIM_LINK_TARGET,LINK_THIS,PRIM_DESC,info]);
    ////
    ///Use this section for ownersay reporting
    /*
    llSetLinkPrimitiveParamsFast(link,[PRIM_TEXT,"\n [LBA DIRECTIONAL] \n ["+(string)((integer)hp)+"/"+(string)((integer)maxhp)+"] \n "+display,<1.-(float)hp/maxhp,(float)hp/maxhp,0.>,1,PRIM_LINK_TARGET,LINK_THIS,PRIM_DESC,info]);
    
    */
    ///Or mix and match!
    llRegionSayTo(user,0,textbuffer);
    if(hp==0)die();
}
open()
{
    llSetLinkPrimitiveParamsFast(-1,[PRIM_TEXT,"",<1,1,1>,1]);
    string parcel=llList2String(llGetParcelDetails(llGetPos(),[PARCEL_DETAILS_DESC]),0);//Fetches parcel description
    list descfind=llParseString2List(parcel,["[:",":]"],[]);//Then sorts through, making new entries for stuff between [: and :]
    integer l=llGetListLength(descfind);//Gets the number of entries
    if(l>0)//Are there any?
    {
        l=l+1;
        while(--l)//Sort through them
        {
            string s=llList2String(descfind,l);
            if(llGetSubString(s,0,8)=="Blackbox:")//Did we find the blackbox entry?
            {
                s=llDeleteSubString(s,0,8);
                blackbox=(key)s;//Assign this shit, fam
                list d=llGetObjectDetails(blackbox,[OBJECT_POS]);
            }
        }
    }
    list bb=llGetBoundingBox(llGetKey());
    min=llList2Vector(bb,0)-<2,2,2>;
    max=llList2Vector(bb,1)+<2,2,2>;
    float t;
    if(min.x>max.x)
    {
        t=min.x;
        min.x=max.x;
        max.x=t;
    }
    if(min.y>max.y)
    {
        t=min.z;
        min.z=max.z;
        max.z=t;
    }
    if(min.z>max.z)
    {
        t=min.z;
        min.z=max.z;
        max.z=t;
    }
    integer hex=(integer)("0x" + llGetSubString(llMD5String((string)myKey,0), 0, 3));//My key hex
    reghex=(integer)("0x" + llGetSubString(llMD5String((string)llGetRegionName(),0), 0, 3));//My region hex
    neghex1 = reghex*-1;//Don't touch me
    neghex2 = reghex*-2;//Or me, we're for blackbox channels
    cleanup=llGetTime()-120;
    if(blackbox=="")
    {
        message=0;
        lh=llListen(hex,"","","");
        lh2=llListen(neghex2,"","","");
        llRegionSay(neghex1,"get");
        //llOwnerSay("No Blackbox found, starting normally");
    }
    else
    {
        message=1;
        lh2=llListen(neghex2,"",blackbox,"");
        llRegionSay(neghex1,"get");
        //llOwnerSay("Blackbox found, awaiting response");
    }
//This function is an added security measure in case people feel like spamming the blackbox reghex channel, to get around a blacklist, 
//return false blacklists, or flood listen events. If you provide a blackbox key in your parcel description, and it is a valid object in the region,
//the reghex listen will specify to only listen to it for blacklists. The format is [:Blackbox:(key):] , you can fetch your blackbox key by 
//rightclicking the object, going to "General", and pressing "Copy keys". If the region is being spammed on the blackbox channel to prevent 
//blacklists from being recieved, this armour will simply not take damage, nor will any other LBA armour in the region.
}
integer reghex;//Region channel for communication with the black box.
integer neghex1;//Negative hex channel for Blackbox interaction
integer neghex2;//Negative hex channel for Blackbox interaction
key blackbox="";//Black box key, Don't touch me, this is what your hitbox communicates with for its blackbox.
integer message=0;//Relates to the blackbox finding, yo.
key myKey;//Me
key myOwner;//Who owns me!
default
{
    state_entry()
    {
        myKey = llGetKey();
        myOwner = llGetOwner();
        open();
        hp=maxhp;
        handlehp();
    }
    on_rez(integer n)
    {
        if(n)
        {
            rezzer = llList2Key(llGetObjectDetails(llGetKey(), [OBJECT_REZZER_KEY]), 0);
            user = llList2Key(llGetObjectDetails(rezzer, [OBJECT_DESC]), 0);
            myKey = llGetKey();
            myOwner = llGetOwner();
            blackbox="";
            llListenRemove(lh);
            llListenRemove(lh2);
            open();
            hp=n;
            handlehp();
            
        }
    }
    changed(integer c)
    {
        if(c&CHANGED_REGION)
        {
            blackbox="";
            llListenRemove(lh2);
            open();
            handlehp();
        }
    }
    collision_start(integer n)
    {
        while(n--)
        {
            key theirkey = llDetectedKey(n);
            vector theirpos = llDetectedPos(n);
            vector theirvel = llDetectedVel(n);
            vector lp=llVecNorm((theirpos-llGetPos())/llGetRot());
            if(llVecMag(theirvel) > 5 && llDetectedType(n) != 3)
            {
                if(llListFindList(impactlist, (list)theirkey)==-1)
                {
                    if(llGetListLength(impactlist)>15)impactlist = [];
                    impactlist += [theirkey, lp];
                }
            }
        }
        if(llVecMag(llDetectedVel(0)) > 25)//If script starts stack heaping, reduce this to ~15
        {
            list sounds = ["9935a340-07f4-7aeb-ce05-2b9a8f511ef2","d4c304a5-add3-0283-0abb-a37b8cfda7e1","c1712505-b648-b06f-91d7-ff0beea46dd1","2b0c2e44-db14-837f-4833-576177d7e463","9616b598-0cc5-871d-d12f-31aa30e6fa60","96cd01ce-2e1c-dd49-ee46-7ffd5c5fb006"];
            llTriggerSound(llList2String(sounds,(integer)llFrand(llGetListLength(sounds))),1);
            //YOUR BULLETS DO NOTHING MORTAL (not necessary but #AESTHETIC
        }
    }
    listen(integer c, string n, key id, string m)
    {
        vector lp=llVecNorm((llList2Vector(llGetObjectDetails(id,[OBJECT_POS]),0)-llGetPos())/llGetRot());
        key rezzerkey = llList2Key(llGetObjectDetails(id,[OBJECT_REZZER_KEY]),0);
        integer impactnum = llListFindList(impactlist,(list)rezzerkey);
        if(impactnum != -1)
        {            
            lp = llList2Vector(impactlist,impactnum+1);
            impactnum = -1;
        }
        impactnum = llListFindList(impactlist,(list)id);
        if(impactnum != -1)
        {
            lp = llList2Vector(impactlist,impactnum+1);
            impactnum = -1;
        }
        if(hp<=0)return;
        list ownerinfo=llGetObjectDetails(id,[OBJECT_OWNER,OBJECT_CREATOR,OBJECT_ATTACHED_POINT]);
        if(c==neghex2)
        {
            if(llList2Key(ownerinfo,1)=="82a665cf-f53b-4c93-87b8-9d0c07c4dbdb")
            {
                blacklist=llParseString2List(m,[","],[]);
                //llOwnerSay("/me : Blacklist Recieved");
                //llOwnerSay(llDumpList2String(blacklist," , "));
                if(message==1)
                {
                    message=0;
                    integer hex=(integer)("0x" + llGetSubString(llMD5String((string)myKey,0), 0, 3));//My key hex.
                    lh=llListen(hex,"","","");
                }
            }
        }
        else
        {
            if(llList2String(ownerinfo,0)=="")return;//Munition needs to stay around for a moment so that you can gather Owner & Creator details, otherwise fuck off.
            if(llStringLength(m)>36)
            {
                key target=llGetSubString(m,0,35);//Gets the target key from the first 36 (The length of a key) characters in the message
                if(target==myKey||target==myOwner)//First things first, am I the target?
                {
                    key owner=llList2Key(ownerinfo,0);//Gets the owner key from Ownerinfo
                    key creator=llList2Key(ownerinfo,1);//Gets the creator key from Ownerinfo
                    integer att=llList2Integer(ownerinfo,2);
                    string n2=llKey2Name(owner);//Gets the owner name
                    if(n2=="")n2=owner;//If you can't get the owner name, return the key instead
                    integer dmg=(integer)llGetSubString(m,37,-1);//This is the damage, fuck you.
                    if (atcap) // use atcap to limit repairs
                    {
                        if (dmg < -atcap) dmg = -atcap;
                    }
                    else if (dmg < -maxhp) // use maxhp to limit repairs
                    {
                        dmg = -maxhp;
                    }
                    if(att)
                    {
                        list tdl=llGetObjectDetails(owner,[OBJECT_POS,OBJECT_ROT]);//target data list
                        vector csize=llGetAgentSize(owner);//Gets hitbox size for camera position adjustment
                        vector tpos=llList2Vector(tdl,0)+<0,0,csize.z/2>;//Their pos
                        rotation trot=llList2Rot(tdl,1);//Their rot
                        vector camvec=tpos+<1,0,0>*trot*llVecDist(tpos,llGetPos());
                        camvec=(camvec-llGetPos())/llGetRot();
                        integer bc=0;
                        if (camvec.x>min.x&&camvec.y>min.y&&camvec.z>min.z&&
                        camvec.x<max.x&&camvec.y<max.y&&camvec.z<max.z)bc=1;
                        if(!bc)
                        {
                            return;
                        }
                    }
                    if(!att)
                    {
                        if(dmg>1)
                        {
                            if(llListFindList(recent,[id])>-1)return;//Check if the object has already damaged you
                            else recent+=id;
                        }
                    }
                    if(dmg>5)llRegionSay(reghex*-3,"log:"+(string)owner+","+(string)creator+","+(string)n+","+(string)dmg);//For logging hits within the region for later evaluation. If you don't have this active, blacklisting won't even work, man.
                    integer dmgmult;
                    if(dmg>0){
                        if(lp.x>0.75){dmgmult=llRound((dmg-.1)*frontmult);}
                        else if(lp.x<-0.75){dmgmult=llRound((dmg-.1)*rearmult);}
                        else if(lp.z>0.4){dmgmult=llRound((dmg-.1)*topmult);}
                        else if(lp.z<-0.4){dmgmult=llRound((dmg-.1)*bottommult);}
                        else{dmgmult = llRound((dmg-.1)*sidemult);}
                        //llOwnerSay((string)dmg+" / " +(string)dmgmult);
                    }
                    proc+=[owner,n2,creator,n,dmg,dmgmult];//Adds to the processing event
                    //llOwnerSay("Proc:"+llList2CSV(proc));
                    ++events;//Adds to events
                    if(events==1)llSetTimerEvent(1*llGetRegionTimeDilation());//On the first event, the processing countdown/timer gets started.
                }
            }
        }
    }
    timer()
    {
        delay++;
        if(delay>3)
        {
            damage=0;
            ctextbuffer="\n";
            handlehp();
            delay=0; 
        }
        integer i=0;
        while(i<events)
        {
            key owner=llList2Key(proc,0);
            string ownern=llList2String(proc,1);
            key creator=llList2Key(proc,2);
            string name=llList2Key(proc,3);
            integer dmg=llList2Integer(proc,4);
            integer dmgmult=llList2Integer(proc,5);
            integer full=dmg;
            if(atcap>0)
            {
                if(dmg>atcap)dmg=atcap;
            }
            proc=llListReplaceList(proc,[],0,5);
            if(llListFindList(blacklist,[(string)owner])==-1&&llListFindList(blacklist,[(string)creator])==-1)
            {
                integer find=llListFindList(totals,[owner,ownern,name]);
                if(full>=1000)
                {
                    totals=llListReplaceList(totals,[],find,find+3);
                    blacklist+=[(string)owner];
                    llRegionSayTo(user,0,(string)ownern+" tried hitting you with "+name+" for a full "+(string)full+" damage, adding to blacklist");
                    llRegionSay(neghex1,"send:"+(string)owner+"||"+(string)creator+"||"+name+"||"+(string)full+"||Oneshot_1/"+(string)dmg+"/"+(string)full+"/"+(string)atcap+"/"+(string)trigger);
                    @black;
                    integer blackfind=llListFindList(proc,[(string)owner]);
                    if(blackfind!=-1)
                    {
                        proc=llListReplaceList(proc,[],blackfind,blackfind+3);
                        --events;
                        jump black;
                    }
                }
                else    
                {
                    if(find!=-1)
                    {
                        integer tdmg=llList2Integer(totals,find+3)+dmg;
                        integer hits=llList2Integer(totals,find+4)+1;
                        integer tdmgmult=llList2Integer(totals,find+5)+dmgmult;
                        totals=llListReplaceList(totals,[tdmg,hits,tdmgmult],find+3,find+5);
                        //llOwnerSay("Test1:"+llList2CSV(totals));
                        if(tdmg>trigger)
                        {
                            if(hits>=6)
                            {
                                integer dph=tdmg/hits;
                                if(dph>5)
                                {
                                    totals=llListReplaceList(totals,[],find,find+4);
                                    blacklist+=[(string)owner];
                                    llRegionSayTo(user,0,(string)ownern+" is spamming you with damage, "+(string)tdmg+" over "+(string)hits+" hits for "+(string)dph+" damage per hit, "+(string)dmg+" on last hit, adding to blacklist");
                                    llRegionSay(neghex1,"send:"+(string)owner+"||"+(string)creator+"||"+name+"||"+(string)full+"||Spam_"+(string)hits+"/"+(string)full+"/"+(string)dph+"/"+(string)atcap+"/"+(string)trigger);
                                    @black2;
                                    integer blackfind=llListFindList(proc,[(string)owner]);
                                    if(blackfind!=-1)
                                    {
                                        proc=llListReplaceList(proc,[],blackfind,blackfind+3);
                                        --events;
                                        jump black2;
                                    }
                                }
                            }
                        }
                    }
                    else totals+=[owner,ownern,name,dmg,1,dmgmult];
                }
            }
            ++i;
        }
        events=0;
        integer buffers;
        buffers=(llGetListLength(totals)+1)/5;
        i=0;
        while(i<buffers)
        {
            integer plus=i*5;
            key owner=llList2Key(totals,plus+0);
            string ownern=llList2Key(totals,plus+1);
            string name=llList2Key(totals,plus+2);
            integer dmg=llList2Integer(totals,plus+3);
            integer hits=llList2Integer(totals,plus+4);
            integer dmgmult=llList2Integer(totals,plus+5);
            //llOwnerSay(llList2CSV(totals));
            if(dmg>0)
            {
                if(hits==1)buffer+="LBA Damage Taken: "+(string)dmgmult +"("+(string)dmg+")"+ "\n"+(string)ownern+"\n"+name;
                else buffer+="LBA Damage Taken: "+(string)dmgmult +"("+(string)dmg+")"+ "\n"+(string)ownern+"\n"+name +"x:"+(string)hits;
                hp-=dmgmult;
            }
            
            else if(dmg<0)
            { 
                if(hits==1)buffer+="LBA Repairs Given: "+(string)(-dmg)+ "\n"+(string)ownern+"\n"+name;
                else buffer+="LBA Repairs Given: "+(string)(-dmg)+ "\n"+(string)ownern+"\n"+name +(string)hits+"x";
                hp-=dmg;
            }
            if(i<buffers-1)buffer+=" \n";
            
            if(hp<=0)hp=0;
            if(hp>=maxhp)hp=maxhp;
            ++i;
        }
        
        textbuffer = (string)buffer;
        //if(buffer!=[])llOwnerSay("\n"+(string)buffer);
        handlehp();
        totals=[];
        buffer=[];
        impactlist=[];
        if(llGetTime()-cleanup>120)
        {
            cleanup=llGetTime();
            recent=[];
            //llSetTimerEvent(0);
        }
    }
    
}
//CHANGELOG ----
//2.06 - Release
//2.06 -> 2.07 - 
//+Added integer neghex1, neghex2 so the script won't have to constantly recalculate reghex*-1/-2
//+Added key myOwner, myKey so it won't have to keep looking for llGetOwner/llGetKey on events
//@ 135,- Fixed first channel check in listener to be == instead of =
//@ 121 - Fixed HP display being lost on region crossing, only showing back up when damage taken.
//2.07 -> 2.1
//+Added list recent, float cleanup
//+Updated collision handling, handlehp(); after all collisions are processed, fors switched to whiles
//2.1 -> 2.2
//+Checks to see if whats damaging it has damaged it before, if the damage is over 1 and not attached
//+If attached, checks if the owner is actually aiming at the hitbox with a 2m margin of error.
//2.1 -> 2.2
//+I FUCKED UP, THE 2M MARGIN OF ERROR DIDN'T TAKE ROTATIONS INTO ACCOUNT LOL
//+This has that fixed, I blame tired scripting and 50 hour work weeks :(
//+Thank jakobbischerk for finding this by trying to repair my barbed wire of all things
//2.21 -> 2.22
//+Negative integer overflow bug fixed, now clamps your repair cap so people can't instakill your shit.
//LBA-Direcitonal Written by Criss Ixtar And Datbot Resident As a plugin for standard LBA.
